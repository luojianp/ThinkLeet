Given a number represented as an array of digits, plus one to the number.
解法： 从前往后加，附带进位。 时间复杂度:o(n)  空间复杂度o(1)

变式:
(1)存储格式变化：一个string中的数，一个数组中的数
（2）数进制变化：二进制，八进制，十六进制，n进制的加法
（3）运算变化（这个会造成之前算法的计算模式改变，可以见c++版150道那里的题）：- （从最低位起步，减之后如果不够补充指定进制的满数，
然后上一位carry为-1。时间复杂度为o(n)，空间复杂度为o(1)）, * (从最低位起步，开辟数组，累积中间结果，时间复杂度o(n)空间复杂度o(n)),
/（从最高位起步，减去指定的被除数，结果往后进行过程中不断地*10）
（4）并行化：
后面对前面结果依赖太强，不好做并行化的问题。如果要是海量数据，每个穿单机能放下，则随便分区，然后每个串都做单机的合并即可。
单个数串太长，单机无法容纳，如何并行化。
n进制的高精度加法：好做，切分串为子串，然后分别加1，然后最后看能累加到哪儿，如果没进位，后面的分区就可以不做了。只不过增加了冗余计算。
但是提升了计算速度。

