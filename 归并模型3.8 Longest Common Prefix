Write a function to find the longest common prefix string amongst an array of strings.
解法： 法1：归并做
       法2,3横向和纵向匹配。见模式匹配总结
       前提：如果预先已经有了长短信息，则最长串首先与最短串进行归并，第二长与第二短的字符串合并，这样则能够节省时间复杂度。
       
       
变式：
存储方式（数组，链表），2个序列或者多
（1）归并排序(数组)
2.1两个数组（6.1 Merge Sorted Array）
方法1：尾插法。时间复杂度(注意时间复杂度易分析不全面)o(n+m)，空间复杂度o(1)。
方法2：递归，函数的返回值为，返回值为该插入的索引。时间复杂度o(m+n)空间复杂度o(m)。
方法3：既然可以递归，就可以用栈做迭代的。
2.2多个数组合并
方法1：纵向尾插
方法2：归并
（2）归并（链表）
2.1两个链表（6.1 Merge Sorted Array）
方法1：头插法。时间复杂度o(n)空间复杂度o(1)
方法2：递归
方法3：栈代替递归递归
2.2多个链表合并（6.3 Merge k Sorted Lists）
方法1：纵向头插  时间复杂度k是几个链表，n代表最大的链表长度 o(k*n) 空间复杂度o(1)
方法2：归并，时间复杂度o(（n）lgk)，空间复杂度o(1)


（3）并行化：
天然的可以并行化的归并模型。
首先一个节点上的分区进行两两归并。最后在一台机器，内存和磁盘均存储数据进行归并
问题:越往后，归并的代价越大，单机越无法容纳。分布式不适合归并排序，适合用terasort方法进行排序。
解决方法：还是得按range分区，然后每个分区中用归并做排序
