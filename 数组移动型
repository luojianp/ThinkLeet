4.1. Given an array [a1, a2, ..., an, b1, b2, ..., bn], transform it to [a1,
b1, a2, b2, ..., an, bn].
时间复杂度:o(nlgn) 空间复杂度o(lgn)
思路：
法1：（不符合） 朴素swap(a2,b1)然后a2-an整体后移，移动a2到b1后面  时间复杂度o(n^2)空间复杂度o(1)
法2： （不符合）优化时间复杂度，开辟一个数组B，直接扫描这个数组A将数据填充到制定位置。时间复杂度o(n) 空间复杂度o(n)
法3：（不符合） 前提：如果a1-an ， b1-bn有序，如果无序这种方法没法做。
权衡现将b1-bn与a相应位置swap，然后对间隔位置的所有a进行排序 时间复杂度o(nlgn) 空间复杂度o(1)
法4： 可以化归转化问题：
      a1,a2,a3,a4,b1,b2,b3,b4
      首先首尾swap保证相应位置元素性质一致
      a1,b3,a3,b1,a4,b2,a2,b4
      转换为子问题；
      例如数量更多的：
      a3,a5,a7,a2,a4,a6,a8排序问题：
      待研究。
法5： 递归转化子问题做
      a1,a2,a3,a4,b1,b2,b3,b4
      a3,a4与b1,b2对调，然后各自再翻转，这样保证子问题还是同样的问题。思路是，因为a3,a4肯定是在另一半的。时间复杂度o(nlgn)空间
      复杂度o(lgn)
      a1,a2,b2,b1
      再翻转
      a1,a2,b1,b2（这个是子问题1） ，剩下的就是子问题2
