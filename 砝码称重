1确定4个砝码能够称出 1-39的数



思路1（暴力扫描）：
直接暴力扫各种情况
4^39个情况，然后每个情况分别验证是否能够覆盖39个数的情况

思路2（不能解决）（从数的范围角度分治）：
二分
先用20切分数为1-20和21-39
转换为子问题 用3个砝码表示1-20个数，这样会6-7个，也就是逻辑树深就是砝码数量。

思路3（暂时不能解决）（从数位角度分治）：
使用数位进行判断：
用1,2能覆盖3，然后再加个砝码4 能覆盖到8 再加个砝码2能覆盖到9
也就是个位能用  1,2,2,4覆盖1-9
十位可以用10和20覆盖到，
3.1目前用6个能够完全覆盖。

3.2还不行，需要进一步的优化
（1）尝试砝码合并。
（2）个位尝试用减法也可以表示   1,3可以表示  1,2,3,4，    1,4可以表示 1,3,4
所以用1,3,5可以表示 1-9这个数。这样节省了1个砝码,问题优化到用5个砝码可以解决
3.3将之前思路再延伸
用3个数表示的最大范围为：1,3,9能连续表示到13,然后13能将39分成3个空间，
所以再加一个26即可。

所以解决方式为（2）（3）的结合，还是分治的方式。

使用1,3,9，和26 能组合出 13,26 
判断数是落入13分成的bucket的哪个中，
0-13 14- 26 27 -39
如果落入 0-13 ，使用1，3,9即可解决。
落入14-26 则将砝码一侧放26，另一侧为待测的数和1,3,9中的砝码
落入27-39，则将29砝码放在 无物品处








问题推广：
（1）4砝码问题已经扩展到极致
1,3肯定得有，为了保证能表示的数据连续性
1,3,7可以扩展到最大11，然后再扩展三份就是33，所以再添加砝码22即可进行区分bucket。
但是1-39已经将4砝码问题扩展到极致。
（2）5砝码问题：
需要看能覆盖的最大连续空间为多大。为39*3的空间
1,3,9,26，39*2
(3)k砝码问题：
公式总结：
1,3,3*3 - 3, 13*3 -13, 39*3 - 3 etc




方法总结：
数问题的分治思路：

（1）Range 分治（相当于从数据库看是水平按元组划分）：
1-20 21-39 二分
（2）数位分治（相当于数据库角度，垂直按列属性划分问题）
个位，十位，百位


